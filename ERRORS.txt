matt@HungLoDE:~/Documents/Repos/Mattcraft$ ./gradlew build
Path for java installation '/usr/lib/jvm/openjdk-17' (Common Linux Locations) does not contain a java executable
Path for java installation '/usr/lib/jvm/openjdk-21' (Common Linux Locations) does not contain a java executable

> Task :compileJava
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/levelgen/Heightmap.java:48: warning: [removal] getHighestSectionPosition() in ChunkAccess has been deprecated and marked for removal
                        int j = chunkAccess.getHighestSectionPosition() + 16;
                                           ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/component/DataComponentPatch.java:57: error: incompatible types: bad return type in lambda expression
                        return reference2ObjectMap;
                               ^
    Map<PatchKey,Object> cannot be converted to Map<PatchKey,CAP#1>
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/levelgen/placement/NoiseBasedCountPlacement.java:35: warning: [removal] BIOME_INFO_NOISE in Biome has been deprecated and marked for removal
                double d = Biome.BIOME_INFO_NOISE.getValue(blockPos.getX() / this.noiseFactor, blockPos.getZ() / this.noiseFactor, false);
                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/levelgen/placement/NoiseThresholdCountPlacement.java:35: warning: [removal] BIOME_INFO_NOISE in Biome has been deprecated and marked for removal
                double d = Biome.BIOME_INFO_NOISE.getValue(blockPos.getX() / 200.0, blockPos.getZ() / 200.0, false);
                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java:228: warning: [removal] getHighestSectionPosition() in ChunkAccess has been deprecated and marked for removal
                int i = levelChunk.getHighestSectionPosition() + 16 - 1;
                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/worldselection/CreateWorldScreen.java:187: error: incompatible types: bad return type in lambda expression
                        dataLoadContext -> new DataLoadOutput<>(
                                                             ^
    cannot infer type arguments for DataLoadOutput<>
      reason: inference variable D has incompatible bounds
        equality constraints: DataLoadOutput<DataPackReloadCookie>
        lower bounds: DataPackReloadCookie
  where D is a type-variable:
    D extends Object declared in record DataLoadOutput
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/worldselection/CreateWorldScreen.java:467: error: incompatible types: bad return type in lambda expression
                                                return new DataLoadOutput<>(new DataPackReloadCookie(worldGenSettings, dataLoadContext.dataConfiguration()), dataLoadContext.datapackDimensions());
                                                                         ^
    cannot infer type arguments for DataLoadOutput<>
      reason: inference variable D has incompatible bounds
        equality constraints: DataLoadOutput<DataPackReloadCookie>
        lower bounds: DataPackReloadCookie
  where D is a type-variable:
    D extends Object declared in record DataLoadOutput
/home/matt/Documents/Repos/Mattcraft/net/minecraft/resources/RegistryDataLoader.java:241: error: incompatible types: inference variable K has incompatible bounds
                        ((Map<?, ?>)entry.getValue()).entrySet().stream().sorted(Entry.comparingByKey()).forEach(entryx -> {
                                                                         ^
    equality constraints: CAP#1
    upper bounds: Comparable<? super K>
  where K,V are type-variables:
    K extends Comparable<? super K> declared in method <K,V>comparingByKey()
    V extends Object declared in method <K,V>comparingByKey()
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/data/info/PacketReport.java:50: error: cannot find symbol
                                jsonObject.add(connectionProtocol.id(), jsonObject2);
                                                                 ^
  symbol:   method id()
  location: variable connectionProtocol of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/data/info/PacketReport.java:51: error: cannot find symbol
                                list.forEach(details -> {
                                    ^
  symbol:   method forEach((details)-[...]}); })
  location: variable list of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/data/info/RegistryDumpReport.java:41: error: incompatible types: Registry<CAP#1> cannot be converted to CAP#2
                int i = builtinRegistry.getId((Registry<?>)registry);
                                              ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Registry<?> from capture of ? extends Registry<?>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/properties/select/ComponentContents.java:32: error: cannot infer type arguments for UnbakedSwitch<>
                                .xmap(list -> new SelectItemModel.UnbakedSwitch<>(new ComponentContents<>(dataComponentType), list), SelectItemModel.UnbakedSwitch::cases)
                                              ^
  reason: inference variable T has incompatible equality constraints CAP#1,CAP#2
  where T is a type-variable:
    T extends Object declared in record ComponentContents
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/properties/select/ComponentContents.java:30: error: cannot find symbol
                        unbakedSwitch -> ((ComponentContents<?>)unbakedSwitch.property()).componentType,
                                                                             ^
  symbol:   method property()
  location: variable unbakedSwitch of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/properties/select/ComponentContents.java:28: error: incompatible types: cannot infer type-variable(s) E,S
                MapCodec<SelectItemModel.UnbakedSwitch<ComponentContents<T>, T>> mapCodec = (MapCodec<SelectItemModel.UnbakedSwitch<ComponentContents<T>, T>>)(MapCodec<?>)codec.dispatchMap(
                                                                                                                                                                                            ^
    (argument mismatch; bad return type in lambda expression
      DataComponentType<CAP#1> cannot be converted to CAP#2)
  where E,A#1,S,A#2 are type-variables:
    E extends Object declared in method <E>dispatchMap(String,Function<? super E,? extends A#1>,Function<? super A#1,? extends MapCodec<? extends E>>)
    A#1 extends Object declared in interface Codec
    S extends Object declared in method <S>xmap(Function<? super A#2,? extends S>,Function<? super S,? extends A#2>)
    A#2 extends Object declared in class MapCodec
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends DataComponentType<?> from capture of ? extends DataComponentType<?>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/inventory/BookViewScreen.java:277: error: incompatible types: List<MutableComponent> cannot be converted to List<Component>
                                return writableBookContent != null ? new BookViewScreen.BookAccess(writableBookContent.getPages(bl).map(Component::literal).toList()) : null;
                                                                                                                                                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/worldselection/EditGameRulesScreen.java:297: error: cannot find symbol
                                                        .forEach(entryx -> this.addEntry((EditGameRulesScreen.RuleEntry)entryx.getValue()));
                                                                                                                              ^
  symbol:   method getValue()
  location: variable entryx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/dedicated/Settings.java:171: error: improperly formed type, type arguments given on a raw type
                return new Settings.MutableValue<>(string, object2, function2);
                                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/dedicated/DedicatedServerProperties.java:236: error: incompatible types: bad return type in lambda expression
                                .or(() -> Optional.ofNullable((ResourceKey)LEGACY_PRESET_NAMES.get(this.levelType)))
                                                             ^
    Optional<ResourceKey> cannot be converted to Optional<? extends ResourceKey<WorldPreset>>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/GameRulesService.java:19: error: type argument Value<?> is not within bounds of type-variable T
                        GameRules.Value<?> value = minecraftApi.gameRuleService().getRule((GameRules.Key<GameRules.Value<?>>)key);
                                                                                                                        ^
  where T is a type-variable:
    T extends Value<T> declared in class Key
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/GameRulesService.java:19: error: method getRule in interface MinecraftGameRuleService cannot be applied to given types;
                        GameRules.Value<?> value = minecraftApi.gameRuleService().getRule((GameRules.Key<GameRules.Value<?>>)key);
                                                                                 ^
  required: Key<T>
  found:    Key<Value<?>>
  reason: inference variable T has incompatible equality constraints CAP#1,Value<?>
  where T is a type-variable:
    T extends Value<T> declared in method <T>getRule(Key<T>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Value<CAP#1> from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/internalapi/MinecraftGameRuleServiceImpl.java:74: error: type argument Value<?> is not within bounds of type-variable T
                return this.server.getGameRules().getRule((net.minecraft.world.level.GameRules.Key<net.minecraft.world.level.GameRules.Value<?>>)key);
                                                                                                                                            ^
  where T is a type-variable:
    T extends Value<T> declared in class Key
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/internalapi/MinecraftGameRuleServiceImpl.java:74: error: method getRule in class GameRules cannot be applied to given types;
                return this.server.getGameRules().getRule((net.minecraft.world.level.GameRules.Key<net.minecraft.world.level.GameRules.Value<?>>)key);
                                                 ^
  required: Key<T>
  found:    Key<Value<?>>
  reason: inference variable T has incompatible equality constraints CAP#1,Value<?>
  where T is a type-variable:
    T extends Value<T> declared in method <T>getRule(Key<T>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Value<CAP#1> from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/OperationArgument.java:57: error: lambda expression not expected here
                return (OperationArgument.Operation)(string.equals("><") ? (scoreAccess, scoreAccess2) -> {
                                                                           ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ReturnCommand.java:25: error: incompatible types: ArgumentBuilder cannot be converted to LiteralArgumentBuilder<T>
                                .then(LiteralArgumentBuilder.<T>literal("run").forward(commandDispatcher.getRoot(), new ReturnCommand.ReturnFromCommandCustomModifier<>(), false))
                                     ^
  where T is a type-variable:
    T extends ExecutionCommandSource<T> declared in method <T>register(CommandDispatcher<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ReturnCommand.java:22: error: incompatible types: inference variable T has incompatible bounds
                        ((LiteralArgumentBuilder)LiteralArgumentBuilder.literal("return").requires(Commands.hasPermission(2)))
                                                                                         ^
    equality constraints: Object
    upper bounds: PermissionSource
  where T is a type-variable:
    T extends PermissionSource declared in method <T>hasPermission(int)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ExecuteCommand.java:986: error: cannot find symbol
                                        .filter(entityx -> !entityx.isRemoved())
                                                                   ^
  symbol:   method isRemoved()
  location: variable entityx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ExecuteCommand.java:987: error: incompatible types: Object cannot be converted to Entity
                                        .map(entityx -> List.of(commandSourceStack.withEntity(entityx)))
                                                                                              ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:57: error: method onProfileLookupSucceeded in interface ProfileLookupCallback cannot be applied to given types;
                                profileLookupCallback.onProfileLookupSucceeded(string, UUIDUtil.createOfflinePlayerUUID(string));
                                                     ^
  required: GameProfile
  found:    String,UUID
  reason: actual and formal argument lists differ in length
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:76: error: <anonymous net.minecraft.server.players.OldUsersConverter$1> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:77: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:167: error: <anonymous net.minecraft.server.players.OldUsersConverter$2> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:168: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:212: error: <anonymous net.minecraft.server.players.OldUsersConverter$3> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:213: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:252: error: <anonymous net.minecraft.server.players.OldUsersConverter$4> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:253: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:299: error: <anonymous net.minecraft.server.players.OldUsersConverter$5> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:300: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/CachedUserNameToIdResolver.java:66: error: cannot find symbol
                        Optional<NameAndId> optional = gameProfileRepository.findProfileByName(string).map(NameAndId::new);
                                                                            ^
  symbol:   method findProfileByName(String)
  location: variable gameProfileRepository of type GameProfileRepository
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/SingletonArgumentInfo.java:18: error: incompatible types: cannot infer type arguments for SingletonArgumentInfo<>
                return new SingletonArgumentInfo<>(commandBuildContext -> (ArgumentType)supplier.get());
                                                ^
    reason: inference variable A has incompatible bounds
      equality constraints: T
      lower bounds: ArgumentType
  where A,T are type-variables:
    A extends ArgumentType<?> declared in class SingletonArgumentInfo
    T extends ArgumentType<?> declared in method <T>contextFree(Supplier<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/SuggestionProviders.java:45: error: incompatible types: RegisteredSuggestion cannot be converted to SuggestionProvider<S>
                        return new SuggestionProviders.RegisteredSuggestion(resourceLocation, suggestionProvider);
                               ^
  where S is a type-variable:
    S extends SharedSuggestionProvider declared in method <S>register(ResourceLocation,SuggestionProvider<SharedSuggestionProvider>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:122: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_or_tag", fixClassType(ResourceOrTagArgument.class), new ResourceOrTagArgument.Info());
                        ^
    (argument mismatch; Class<ResourceOrTagArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:123: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_or_tag_key", fixClassType(ResourceOrTagKeyArgument.class), new ResourceOrTagKeyArgument.Info());
                        ^
    (argument mismatch; Class<ResourceOrTagKeyArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:124: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource", fixClassType(ResourceArgument.class), new ResourceArgument.Info());
                        ^
    (argument mismatch; Class<ResourceArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:125: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_key", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info());
                        ^
    (argument mismatch; Class<ResourceKeyArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:126: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_selector", fixClassType(ResourceSelectorArgument.class), new ResourceSelectorArgument.Info());
                        ^
    (argument mismatch; Class<ResourceSelectorArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/execution/tasks/BuildContexts.java:56: error: RedirectModifier<T> cannot be safely cast to CustomModifierExecutor<T>
                                        if (redirectModifier instanceof CustomModifierExecutor<T> customModifierExecutor) {
                                            ^
  where T is a type-variable:
    T extends ExecutionCommandSource<T> declared in class BuildContexts
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/execution/tasks/BuildContexts.java:93: error: cannot infer type arguments for CommandQueueEntry<>
                                executionContext.queueNext(new CommandQueueEntry<>(frame, FallthroughTask.instance()));
                                                           ^
  reason: inferred type does not conform to equality constraint(s)
    inferred: T#1
    equality constraints(s): T#1,T#2
  where T#1,T#2 are type-variables:
    T#1 extends ExecutionCommandSource<T#1>
    T#2 extends ExecutionCommandSource<T#1>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/execution/tasks/BuildContexts.java:97: error: Command<T> cannot be safely cast to CustomCommandExecutor<T>
                        if (commandContext2.getCommand() instanceof CustomCommandExecutor<T> customCommandExecutor) {
                                                      ^
  where T is a type-variable:
    T extends ExecutionCommandSource<T> declared in class BuildContexts
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/EncoderCache.java:34: error: incompatible types: inference variable T#1 has incompatible bounds
                                        .map(objectx -> objectx instanceof Tag tag ? tag.copy() : objectx);
                                            ^
    equality constraints: T#2
    lower bounds: CAP#1,Tag
  where T#1,R,T#2,A are type-variables:
    T#1 extends Object declared in method <T#1>map(Function<? super R,? extends T#1>)
    R extends Object declared in interface DataResult
    T#2 extends Object declared in method <T#2>encode(A,DynamicOps<T#2>,T#2)
    A extends Object declared in method <A>wrap(Codec<A>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/LegacyHoverEventFix.java:63: error: incompatible types: invalid method reference
                                                        String string = (String)((Either)pairxxx.getFirst()).left().map(Pair::getFirst).orElse("");
                                                                                                                        ^
    method getFirst in class Pair<F,S> cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
  where F,S are type-variables:
    F extends Object declared in class Pair
    S extends Object declared in class Pair
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityUUIDFix.java:105: error: incompatible types: Stream<Dynamic> cannot be converted to Stream<? extends Dynamic<?>>
                        .map(dynamic2 -> dynamic.createList(dynamic2.asStream().map(dynamicxx -> (Dynamic)createUUIDFromML(dynamicxx).orElseGet(() -> {
                                                                                   ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityUUIDFix.java:139: error: incompatible types: cannot infer type-variable(s) R
                                                                dynamic2x.asStream().map(dynamicxxxx -> (Dynamic)replaceUUIDLeastMost(dynamicxxxx, "UUID", "UUID").orElse(dynamicxxxx))
                                                                                        ^
    (argument mismatch; incompatible parameter types in lambda expression)
  where R,T are type-variables:
    R extends Object declared in method <R>map(Function<? super T,? extends R>)
    T extends Object declared in interface Stream
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java:132: error: cannot find symbol
                                .mapToInt(dynamicx -> dynamicx.asShort((short)-1))
                                                              ^
  symbol:   method asShort(short)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java:181: error: incompatible types: ImmutableMap<Object,Object> cannot be converted to Map<? extends Dynamic<?>,? extends Dynamic<?>>
                                .build()
                                      ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityBlockStateFix.java:328: error: incompatible types: invalid method reference
                        int i = either.<Integer>map(pair -> ((Either)pair.getSecond()).map(integer -> integer, EntityBlockStateFix::getBlockId), unit -> {
                                                                                                               ^
    incompatible types: Object cannot be converted to String
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityBlockStateFix.java:344: error: incompatible types: invalid method reference
                        int i = ((Either)pair.getSecond()).<Integer>map(integer -> integer, EntityBlockStateFix::getBlockId);
                                                                                            ^
    incompatible types: Object cannot be converted to String
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityVariantFix.java:26: error: incompatible types: bad return type in lambda expression
                        Function<T, T> function2 = objectx -> ((Dynamic)function.apply(new Dynamic<>(dynamicOps, (T)objectx))).getValue();
                                                                                                                                       ^
    Object cannot be converted to T
  where T is a type-variable:
    T extends Object declared in method <T>updateAndRename(Dynamic<T>,String,String,Function<Dynamic<T>,Dynamic<T>>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/StatsCounterFix.java:244: error: incompatible types: Object cannot be converted to Entry<? extends Dynamic<?>,? extends Dynamic<?>>
                                for (Entry<? extends Dynamic<?>, ? extends Dynamic<?>> entry : ((Map)optional.get()).entrySet()) {
                                                                                                                             ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/DropInvalidSignDataFix.java:43: error: incompatible types: Stream<Dynamic<T>> cannot be converted to Stream<Dynamic>
                        List<Dynamic<T>> list2 = Streams.<Dynamic, Dynamic<T>>mapWithIndex((Stream<Dynamic>)optional.get(), (dynamic2x, l) -> {
                                                                                                                        ^
  where T is a type-variable:
    T extends Object declared in method <T>fixText(Dynamic<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/TextComponentHoverAndClickEventFix.java:57: error: cannot find symbol
                                                Pair<Either<H, Unit>, Dynamic<?>> pair2 = (Pair<Either<H, Unit>, Dynamic<?>>)((Pair)pairx.getSecond()).getSecond();
                                                                                                                                         ^
  symbol:   method getSecond()
  location: variable pairx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/TextComponentHoverAndClickEventFix.java:56: error: incompatible types: Object cannot be converted to boolean
                                        boolean bl = ((Either)pair.getSecond()).<Boolean>map(either -> false, pairx -> {
                                                                                            ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/TextComponentHoverAndClickEventFix.java:51: error: incompatible types: inference variable B has incompatible bounds
                        return this.fixTypeEverywhere(
                                                     ^
    equality constraints: C2
    lower bounds: C2,Pair<String,Either<Either<String,List<C1>>,Pair<Either<List<C1>,Unit>,Pair<Either<C1,Unit>,Pair<Either<H,Unit>,Dynamic<?>>>>>>
  where B,A,C2,C1,H are type-variables:
    B extends Object declared in method <A,B>fixTypeEverywhere(String,Type<A>,Type<B>,Function<DynamicOps<?>,Function<A,B>>)
    A extends Object declared in method <A,B>fixTypeEverywhere(String,Type<A>,Type<B>,Function<DynamicOps<?>,Function<A,B>>)
    C2 extends Object declared in method <C1,C2,H>createFixer(Type<C1>,Type<C2>,Type<H>)
    C1 extends Object declared in method <C1,C2,H>createFixer(Type<C1>,Type<C2>,Type<H>)
    H extends Pair<String,?> declared in method <C1,C2,H>createFixer(Type<C1>,Type<C2>,Type<H>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ItemPotionFix.java:171: error: incompatible types: Object cannot be converted to Dynamic<?>
                                                Dynamic<?> dynamic2 = ((Typed)optional2.get()).get(DSL.remainderFinder());
                                                                                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkBedBlockEntityInjecterFix.java:42: error: incompatible types: cannot infer type-variable(s) A,B
                        this.fixTypeEverywhere(
                                              ^
    (argument mismatch; bad return type in lambda expression
      incompatible parameter types in lambda expression)
  where A,B are type-variables:
    A extends Object declared in method <A,B>fixTypeEverywhere(String,Type<A>,Type<B>,Function<DynamicOps<?>,Function<A,B>>)
    B extends Object declared in method <A,B>fixTypeEverywhere(String,Type<A>,Type<B>,Function<DynamicOps<?>,Function<A,B>>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkBedBlockEntityInjecterFix.java:82: error: incompatible types: Object cannot be converted to TE
                                                                                                .getFirst()
                                                                                                         ^
  where TE is a type-variable:
    TE extends Object declared in method <TE>cap(Type<?>,ListType<TE>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntitySpawnerItemVariantComponentFix.java:35: error: no suitable method found for updateTyped(OpticFinder<CAP#1>,EntitySpaw[...]ucket)
                                        case "minecraft:salmon_bucket" -> typed.updateTyped(opticFinder2, EntitySpawnerItemVariantComponentFix::fixSalmonBucket);
                                                                               ^
    method Typed.<FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#1
        (argument mismatch; incompatible parameter types in method reference))
    method Typed.<FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#2,FR
        (actual and formal argument lists differ in length))
  where FT#1,FT#2,FR are type-variables:
    FT#1 extends Object declared in method <FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>)
    FT#2 extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
    FR extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntitySpawnerItemVariantComponentFix.java:36: error: no suitable method found for updateTyped(OpticFinder<CAP#1>,EntitySpaw[...]ucket)
                                        case "minecraft:axolotl_bucket" -> typed.updateTyped(opticFinder2, EntitySpawnerItemVariantComponentFix::fixAxolotlBucket);
                                                                                ^
    method Typed.<FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#1
        (argument mismatch; incompatible parameter types in method reference))
    method Typed.<FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#2,FR
        (actual and formal argument lists differ in length))
  where FT#1,FT#2,FR are type-variables:
    FT#1 extends Object declared in method <FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>)
    FT#2 extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
    FR extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntitySpawnerItemVariantComponentFix.java:37: error: no suitable method found for updateTyped(OpticFinder<CAP#1>,EntitySpaw[...]ucket)
                                        case "minecraft:tropical_fish_bucket" -> typed.updateTyped(opticFinder2, EntitySpawnerItemVariantComponentFix::fixTropicalFishBucket);
                                                                                      ^
    method Typed.<FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#1
        (argument mismatch; incompatible parameter types in method reference))
    method Typed.<FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#2,FR
        (actual and formal argument lists differ in length))
  where FT#1,FT#2,FR are type-variables:
    FT#1 extends Object declared in method <FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>)
    FT#2 extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
    FR extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/MobSpawnerEntityIdentifiersFix.java:41: error: cannot find symbol
                                                                        Optional<String> optionalx = dynamicx.get("Type").asString().result();
                                                                                                             ^
  symbol:   method get(String)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/MobSpawnerEntityIdentifiersFix.java:43: error: cannot find symbol
                                                                                Dynamic<?> dynamic2 = DataFixUtils.orElse(dynamicx.get("Properties").result(), dynamicx.emptyMap())
                                                                                                                                  ^
  symbol:   method get(String)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/MobSpawnerEntityIdentifiersFix.java:43: error: cannot find symbol
                                                                                Dynamic<?> dynamic2 = DataFixUtils.orElse(dynamicx.get("Properties").result(), dynamicx.emptyMap())
                                                                                                                                                                       ^
  symbol:   method emptyMap()
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/MobSpawnerEntityIdentifiersFix.java:44: error: cannot find symbol
                                                                                        .set("id", dynamicx.createString((String)optionalx.get()));
                                                                                                           ^
  symbol:   method createString(String)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/MobSpawnerEntityIdentifiersFix.java:45: error: cannot find symbol
                                                                                return dynamicx.set("Entity", dynamic2).remove("Type").remove("Properties");
                                                                                               ^
  symbol:   method set(String,Dynamic<CAP#1>)
  location: variable dynamicx of type Object
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/OverreachingTickFix.java:39: error: cannot find symbol
                                int k = dynamicx.get("x").asInt(0);
                                                ^
  symbol:   method get(String)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/OverreachingTickFix.java:40: error: cannot find symbol
                                int l = dynamicx.get("z").asInt(0);
                                                ^
  symbol:   method get(String)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EmptyItemInHotbarFix.java:27: error: incompatible types: invalid method reference
                                Optional<String> optional = ((Either)pairx.getFirst()).left().map(Pair::getSecond);
                                                                                                  ^
    method getSecond in class Pair<F,S> cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
  where F,S are type-variables:
    F extends Object declared in class Pair
    S extends Object declared in class Pair
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/SavedDataUUIDFix.java:34: error: incompatible types: cannot infer type-variable(s) R
                                                                                        dynamicxxxx.asStream().map(dynamicxxxxx -> (Dynamic)createUUIDFromLongs(dynamicxxxxx, "UUIDMost", "UUIDLeast").orElseGet(() -> {
                                                                                                                  ^
    (argument mismatch; incompatible parameter types in lambda expression)
  where R,T are type-variables:
    R extends Object declared in method <R>map(Function<? super T,? extends R>)
    T extends Object declared in interface Stream
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/FixProjectileStoredItem.java:47: error: incompatible types: Type<T> cannot be converted to Type<CAP#1>
                return typed -> typed.updateTyped(opticFinder, type2, typedx -> subFixer.fix(typedx, type2));
                                                                                                     ^
  where T is a type-variable:
    T extends Object declared in method <T>fixChoiceCap(String,SubFixer<?>,Type<?>,Type<T>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EffectDurationFix.java:36: error: incompatible types: Object cannot be converted to Dynamic<?>
                                                Dynamic<?> dynamic = ((Typed)optional.get()).get(DSL.remainderFinder());
                                                                                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/OptionsKeyLwjgl3Fix.java:168: error: incompatible types: Map<Dynamic,Dynamic> cannot be converted to Map<? extends Dynamic<?>,? extends Dynamic<?>>
                                        }).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond))))
                                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityEquipmentToArmorAndHandFix.java:75: error: incompatible types: ItemStackOld cannot be converted to ItemStackNew
                                                                        list2.set(i - 1, list.get(i));
                                                                                                 ^
  where ItemStackOld,ItemStackNew are type-variables:
    ItemStackOld extends Object declared in method <ItemStackOld,ItemStackNew>cap(Type<ItemStackOld>,Type<ItemStackNew>)
    ItemStackNew extends Object declared in method <ItemStackOld,ItemStackNew>cap(Type<ItemStackOld>,Type<ItemStackNew>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityEquipmentToArmorAndHandFix.java:93: error: cannot find symbol
                        Iterator<Float> iterator = Stream.concat(((Stream)optional.get()).map(dynamicx -> dynamicx.asFloat(0.0F)), Stream.generate(() -> 0.0F)).iterator();
                                                                                                                  ^
  symbol:   method asFloat(float)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/GossipUUIDFix.java:24: error: incompatible types: invalid method reference
                                                .map(dynamicx::createList),
                                                     ^
    incompatible types: Stream<Dynamic> cannot be converted to Stream<? extends Dynamic<?>>
  where T is a type-variable:
    T extends Object declared in class DynamicLike
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ItemStackUUIDFix.java:35: error: incompatible types: cannot infer type-variable(s) R
                        dynamic2 -> dynamic.createList(dynamic2.asStream().map(dynamicxx -> (Dynamic)replaceUUIDLeastMost(dynamicxx, "UUID", "UUID").orElse(dynamicxx)))
                                                                              ^
    (argument mismatch; incompatible parameter types in lambda expression)
  where R,T are type-variables:
    R extends Object declared in method <R>map(Function<? super T,? extends R>)
    T extends Object declared in interface Stream
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ItemStackComponentizationFix.java:376: error: cannot find symbol
                                                        .map(dynamicx -> DataFixUtils.orElse(dynamicx.asString().map(stringx -> fixBlockStatePredicate(dynamicx, stringx)).result(), dynamicx))
                                                                                                     ^
  symbol:   method asString()
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ItemStackComponentizationFix.java:686: error: cannot find symbol
                                                                                .set("value", optionalDynamic.createString((String)pair.getFirst()));
                                                                                                                                       ^
  symbol:   method getFirst()
  location: variable pair of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ItemStackComponentizationFix.java:687: error: cannot find symbol
                                                                        Optional<String> optional = (Optional<String>)pair.getSecond();
                                                                                                                          ^
  symbol:   method getSecond()
  location: variable pair of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/BlockEntitySignDoubleSidedEditableTextFix.java:38: error: incompatible types: List<Dynamic> cannot be converted to List<Dynamic<T>>
                List<Dynamic<T>> list = getLines(dynamic, "Text").map(optional -> (Dynamic)optional.orElse(dynamic2)).toList();
                                                                                                                            ^
  where T is a type-variable:
    T extends Object declared in method <T>fixFrontTextTag(Dynamic<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EquipmentFormatFix.java:65: error: incompatible types: inference variable F has incompatible bounds
                        return this.fixTypeEverywhere(
                                                     ^
    equality constraints: Either<ItemStackNew,Unit>
    lower bounds: Either<ItemStackOld,Unit>
  where F,S,ItemStackNew,ItemStackOld are type-variables:
    F extends Object declared in method <F,S>of(F,S)
    S extends Object declared in method <F,S>of(F,S)
    ItemStackNew extends Object declared in method <ItemStackOld,ItemStackNew>fix(Type<ItemStackOld>,Type<ItemStackNew>,OpticFinder<?>)
    ItemStackOld extends Object declared in method <ItemStackOld,ItemStackNew>fix(Type<ItemStackOld>,Type<ItemStackNew>,OpticFinder<?>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/OptionsKeyTranslationFix.java:34: error: incompatible types: Map<Dynamic,CAP#1> cannot be converted to Map<? extends Dynamic<?>,? extends Dynamic<?>>
                                        }).collect(Collectors.toMap(Pair::getFirst, Pair::getSecond))))
                                                  ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Dynamic from capture of ? extends Dynamic
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/LevelDataGeneratorOptionsFix.java:194: error: cannot find symbol
                                                                .map(entryx -> Pair.of(dynamicOps.createString((String)entryx.getKey()), dynamicOps.createString((String)entryx.getValue())))
                                                                                                                             ^
  symbol:   method getKey()
  location: variable entryx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/LevelDataGeneratorOptionsFix.java:194: error: cannot find symbol
                                                                .map(entryx -> Pair.of(dynamicOps.createString((String)entryx.getKey()), dynamicOps.createString((String)entryx.getValue())))
                                                                                                                                                                               ^
  symbol:   method getValue()
  location: variable entryx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/LevelDataGeneratorOptionsFix.java:195: error: incompatible types: cannot infer type-variable(s) T,K,U
                                                                .collect(Collectors.toMap(Pair::getFirst, Pair::getSecond))
                                                                                         ^
    (argument mismatch; invalid method reference
      method getFirst in class Pair<F,S> cannot be applied to given types
        required: no arguments
        found:    Object
        reason: actual and formal argument lists differ in length)
  where T,K,U,F,S are type-variables:
    T extends Object declared in method <T,K,U>toMap(Function<? super T,? extends K>,Function<? super T,? extends U>)
    K extends Object declared in method <T,K,U>toMap(Function<? super T,? extends K>,Function<? super T,? extends U>)
    U extends Object declared in method <T,K,U>toMap(Function<? super T,? extends K>,Function<? super T,? extends U>)
    F extends Object declared in class Pair
    S extends Object declared in class Pair
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkToProtochunkFix.java:70: error: incompatible types: List<ShortArrayList> cannot be converted to List<ShortList>
                                                List<ShortList> list = (List<ShortList>)IntStream.range(0, 16).mapToObj(i -> new ShortArrayList()).collect(Collectors.toList());
                                                                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/LevelUUIDFix.java:48: error: incompatible types: cannot infer type-variable(s) R
                return dynamic.update("Players", dynamic2 -> dynamic.createList(dynamic2.asStream().map(dynamicxx -> (Dynamic)createUUIDFromML(dynamicxx).orElseGet(() -> {
                                                                                                       ^
    (argument mismatch; incompatible parameter types in lambda expression)
  where R,T are type-variables:
    R extends Object declared in method <R>map(Function<? super T,? extends R>)
    T extends Object declared in interface Stream
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/BlockEntityUUIDFix.java:26: error: incompatible types: Dynamic<CAP#1> cannot be converted to Dynamic<CAP#2>
                        .orElse(dynamic);
                                ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/StructuresBecomeConfiguredFix.java:224: error: incompatible types: Object cannot be converted to String
                                ((List)entry.getKey()).forEach(string -> builder.put(string, (String)entry.getValue()));
                                                                                     ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/DataFixers.java:1117: error: incompatible types: bad return type in method reference
                                schema164, "Change cat variant type", References.ENTITY, "minecraft:cat", "CatType", Util.make(new Int2ObjectOpenHashMap(), int2ObjectOpenHashMap -> {
                                                                                                                     ^
    Object cannot be converted to String
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/DataFixers.java:1154: error: incompatible types: bad return type in method reference
                                schema165, "Change frog variant type", References.ENTITY, "minecraft:frog", "Variant", Util.make(new Int2ObjectOpenHashMap(), int2ObjectOpenHashMap -> {
                                                                                                                       ^
    Object cannot be converted to String
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/profiling/FilledProfileResults.java:51: error: cannot find symbol
                        Comparator.comparingLong(counterCollector -> counterCollector.totalValue)
                                                                                     ^
  symbol:   variable totalValue
  location: variable counterCollector of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/profiling/FilledProfileResults.java:53: error: incompatible types: Comparator<Entry<Object,Object>> cannot be converted to Comparator<Entry<String,CounterCollector>>
                .reversed();
                         ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/profiling/jfr/stats/FileIOStat.java:26: error: cannot find symbol
                                .map(entry -> Pair.of((String)entry.getKey(), (Long)entry.getValue()))
                                                                   ^
  symbol:   method getKey()
  location: variable entry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/profiling/jfr/stats/FileIOStat.java:26: error: cannot find symbol
                                .map(entry -> Pair.of((String)entry.getKey(), (Long)entry.getValue()))
                                                                                         ^
  symbol:   method getValue()
  location: variable entry of type Object
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
Note: Some messages have been simplified; recompile with -Xdiags:verbose to get full output
100 errors
4 warnings
only showing the first 100 errors, of 184 total; use -Xmaxerrs if you would like to see more

> Task :compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileJava'.
> Compilation failed; see the compiler error output for details.

* Try:
> Run with --info option to get more log output.
> Run with --scan to get full insights.

BUILD FAILED in 17s
1 actionable task: 1 executed
matt@HungLoDE:~/Documents/Repos/Mattcraft$



