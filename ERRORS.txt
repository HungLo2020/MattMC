matt@HungLoDE:~/Documents/Repos/Mattcraft$ ./gradlew build
Path for java installation '/usr/lib/jvm/openjdk-21' (Common Linux Locations) does not contain a java executable
Path for java installation '/usr/lib/jvm/openjdk-17' (Common Linux Locations) does not contain a java executable

> Task :compileJava
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/levelgen/Heightmap.java:48: warning: [removal] getHighestSectionPosition() in ChunkAccess has been deprecated and marked for removal
                        int j = chunkAccess.getHighestSectionPosition() + 16;
                                           ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/component/DataComponentPatch.java:57: error: incompatible types: bad return type in lambda expression
                        return reference2ObjectMap;
                               ^
    Map<PatchKey,Object> cannot be converted to Map<PatchKey,CAP#1>
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/levelgen/placement/NoiseBasedCountPlacement.java:35: warning: [removal] BIOME_INFO_NOISE in Biome has been deprecated and marked for removal
                double d = Biome.BIOME_INFO_NOISE.getValue(blockPos.getX() / this.noiseFactor, blockPos.getZ() / this.noiseFactor, false);
                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/levelgen/placement/NoiseThresholdCountPlacement.java:35: warning: [removal] BIOME_INFO_NOISE in Biome has been deprecated and marked for removal
                double d = Biome.BIOME_INFO_NOISE.getValue(blockPos.getX() / 200.0, blockPos.getZ() / 200.0, false);
                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java:228: warning: [removal] getHighestSectionPosition() in ChunkAccess has been deprecated and marked for removal
                int i = levelChunk.getHighestSectionPosition() + 16 - 1;
                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/worldselection/CreateWorldScreen.java:187: error: incompatible types: bad return type in lambda expression
                        dataLoadContext -> new DataLoadOutput<>(
                                                             ^
    cannot infer type arguments for DataLoadOutput<>
      reason: inference variable D has incompatible bounds
        equality constraints: DataLoadOutput<DataPackReloadCookie>
        lower bounds: DataPackReloadCookie
  where D is a type-variable:
    D extends Object declared in record DataLoadOutput
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/worldselection/CreateWorldScreen.java:467: error: incompatible types: bad return type in lambda expression
                                                return new DataLoadOutput<>(new DataPackReloadCookie(worldGenSettings, dataLoadContext.dataConfiguration()), dataLoadContext.datapackDimensions());
                                                                         ^
    cannot infer type arguments for DataLoadOutput<>
      reason: inference variable D has incompatible bounds
        equality constraints: DataLoadOutput<DataPackReloadCookie>
        lower bounds: DataPackReloadCookie
  where D is a type-variable:
    D extends Object declared in record DataLoadOutput
/home/matt/Documents/Repos/Mattcraft/net/minecraft/resources/RegistryDataLoader.java:241: error: incompatible types: inference variable K has incompatible bounds
                        ((Map<?, ?>)entry.getValue()).entrySet().stream().sorted(Entry.comparingByKey()).forEach(entryx -> {
                                                                         ^
    equality constraints: CAP#1
    upper bounds: Comparable<? super K>
  where K,V are type-variables:
    K extends Comparable<? super K> declared in method <K,V>comparingByKey()
    V extends Object declared in method <K,V>comparingByKey()
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/data/info/PacketReport.java:50: error: cannot find symbol
                                jsonObject.add(connectionProtocol.id(), jsonObject2);
                                                                 ^
  symbol:   method id()
  location: variable connectionProtocol of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/data/info/PacketReport.java:51: error: cannot find symbol
                                list.forEach(details -> {
                                    ^
  symbol:   method forEach((details)-[...]}); })
  location: variable list of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/data/info/RegistryDumpReport.java:41: error: incompatible types: Registry<CAP#1> cannot be converted to CAP#2
                int i = builtinRegistry.getId((Registry<?>)registry);
                                              ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Registry<?> from capture of ? extends Registry<?>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/properties/select/ComponentContents.java:32: error: cannot infer type arguments for UnbakedSwitch<>
                                .xmap(list -> new SelectItemModel.UnbakedSwitch<>(new ComponentContents<>(dataComponentType), list), SelectItemModel.UnbakedSwitch::cases)
                                              ^
  reason: inference variable T has incompatible equality constraints CAP#1,CAP#2
  where T is a type-variable:
    T extends Object declared in record ComponentContents
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/properties/select/ComponentContents.java:30: error: cannot find symbol
                        unbakedSwitch -> ((ComponentContents<?>)unbakedSwitch.property()).componentType,
                                                                             ^
  symbol:   method property()
  location: variable unbakedSwitch of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/properties/select/ComponentContents.java:28: error: incompatible types: cannot infer type-variable(s) E,S
                MapCodec<SelectItemModel.UnbakedSwitch<ComponentContents<T>, T>> mapCodec = (MapCodec<SelectItemModel.UnbakedSwitch<ComponentContents<T>, T>>)(MapCodec<?>)codec.dispatchMap(
                                                                                                                                                                                            ^
    (argument mismatch; bad return type in lambda expression
      DataComponentType<CAP#1> cannot be converted to CAP#2)
  where E,A#1,S,A#2 are type-variables:
    E extends Object declared in method <E>dispatchMap(String,Function<? super E,? extends A#1>,Function<? super A#1,? extends MapCodec<? extends E>>)
    A#1 extends Object declared in interface Codec
    S extends Object declared in method <S>xmap(Function<? super A#2,? extends S>,Function<? super S,? extends A#2>)
    A#2 extends Object declared in class MapCodec
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends DataComponentType<?> from capture of ? extends DataComponentType<?>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/ConditionalItemModel.java:89: error: cannot find symbol
                        Codec<T> codec = (Codec<T>)conditionalItemModelProperty.type().codec();
                        ^
  symbol:   class Codec
  location: class Unbaked
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/renderer/item/ConditionalItemModel.java:89: error: cannot find symbol
                        Codec<T> codec = (Codec<T>)conditionalItemModelProperty.type().codec();
                                          ^
  symbol:   class Codec
  location: class Unbaked
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/inventory/BookViewScreen.java:277: error: incompatible types: List<MutableComponent> cannot be converted to List<Component>
                                return writableBookContent != null ? new BookViewScreen.BookAccess(writableBookContent.getPages(bl).map(Component::literal).toList()) : null;
                                                                                                                                                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:139: error: cannot find symbol
                        if (this.minecraft.isLocalPlayer(playerEntry.getPlayerId())) {
                                                                    ^
  symbol:   method getPlayerId()
  location: variable playerEntry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:141: error: cannot find symbol
                        } else if (this.minecraft.getReportingContext().hasDraftReportFor(playerEntry.getPlayerId())) {
                                                                                                     ^
  symbol:   method getPlayerId()
  location: variable playerEntry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:143: error: cannot find symbol
                        } else if (playerEntry.getPlayerId().version() == 2) {
                                              ^
  symbol:   method getPlayerId()
  location: variable playerEntry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:146: error: cannot find symbol
                                return playerEntry.hasRecentMessages() ? 2 : 3;
                                                  ^
  symbol:   method hasRecentMessages()
  location: variable playerEntry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:149: error: cannot find symbol
                        if (!playerEntry.getPlayerName().isBlank()) {
                                        ^
  symbol:   method getPlayerName()
  location: variable playerEntry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:150: error: cannot find symbol
                                int i = playerEntry.getPlayerName().codePointAt(0);
                                                   ^
  symbol:   method getPlayerName()
  location: variable playerEntry of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/social/SocialInteractionsPlayerList.java:157: error: no suitable method found for thenComparing(PlayerEntr[...]rName,String::co[...]eCase)
                }).thenComparing(PlayerEntry::getPlayerName, String::compareToIgnoreCase));
                  ^
    method Comparator.<U#1>thenComparing(Function<? super Object,? extends U#1>,Comparator<? super U#1>) is not applicable
      (cannot infer type-variable(s) U#1
        (argument mismatch; invalid method reference
          method getPlayerName in class PlayerEntry cannot be applied to given types
            required: no arguments
            found:    Object
            reason: actual and formal argument lists differ in length))
    method Comparator.<U#2>thenComparing(Function<? super Object,? extends U#2>) is not applicable
      (cannot infer type-variable(s) U#2
        (actual and formal argument lists differ in length))
  where U#1,T,U#2 are type-variables:
    U#1 extends Object declared in method <U#1>thenComparing(Function<? super T,? extends U#1>,Comparator<? super U#1>)
    T extends Object declared in interface Comparator
    U#2 extends Comparable<? super U#2> declared in method <U#2>thenComparing(Function<? super T,? extends U#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/PresetFlatWorldScreen.java:306: error: incompatible types: Component cannot be converted to MutableComponent
                                        .orElse(PresetFlatWorldScreen.UNKNOWN_PRESET);
                                                                     ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/AccessibilityOnboardingScreen.java:166: error: method say in interface Narrator cannot be applied to given types;
                                Narrator.getNarrator().say(ONBOARDING_NARRATOR_MESSAGE.getString(), true, this.minecraft.options.getFinalSoundSourceVolume(SoundSource.VOICE));
                                                      ^
  required: String,boolean
  found:    String,boolean,float
  reason: actual and formal argument lists differ in length
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/gui/screens/worldselection/EditGameRulesScreen.java:296: error: incompatible types: cannot infer type-variable(s) T#1,U
                                                        .sorted(java.util.Map.Entry.comparingByKey(Comparator.comparing(Key::getId)))
                                                                                                  ^
    (argument mismatch; invalid method reference
      method getId in class Key<T#2> cannot be applied to given types
        required: no arguments
        found:    Object
        reason: actual and formal argument lists differ in length)
  where T#1,U,T#2 are type-variables:
    T#1 extends Object declared in method <T#1,U>comparing(Function<? super T#1,? extends U>)
    U extends Comparable<? super U> declared in method <T#1,U>comparing(Function<? super T#1,? extends U>)
    T#2 extends Value<T#2> declared in class Key
/home/matt/Documents/Repos/Mattcraft/net/minecraft/network/protocol/configuration/ClientboundUpdateEnabledFeaturesPacket.java:17: error: reference to ClientboundUpdateEnabledFeaturesPacket is ambiguous
                this(friendlyByteBuf.readCollection(HashSet::new, FriendlyByteBuf::readResourceLocation));
                ^
  both constructor ClientboundUpdateEnabledFeaturesPacket(FriendlyByteBuf) in ClientboundUpdateEnabledFeaturesPacket and constructor ClientboundUpdateEnabledFeaturesPacket(Set<ResourceLocation>) in ClientboundUpdateEnabledFeaturesPacket match
/home/matt/Documents/Repos/Mattcraft/net/minecraft/network/protocol/configuration/ClientboundUpdateEnabledFeaturesPacket.java:17: error: incompatible types: inference variable C has incompatible bounds
                this(friendlyByteBuf.readCollection(HashSet::new, FriendlyByteBuf::readResourceLocation));
                                                   ^
    upper bounds: FriendlyByteBuf,Collection<T>
    lower bounds: HashSet<E>
  where C,T,E are type-variables:
    C extends Collection<T> declared in method <T,C>readCollection(IntFunction<C>,StreamDecoder<? super FriendlyByteBuf,T>)
    T extends Object declared in method <T,C>readCollection(IntFunction<C>,StreamDecoder<? super FriendlyByteBuf,T>)
    E extends Object declared in class HashSet
/home/matt/Documents/Repos/Mattcraft/net/minecraft/client/multiplayer/AccountProfileKeyPairManager.java:62: error: incompatible types: invalid method reference
                        ? (Boolean)((Optional)this.keyPair.join()).map(ProfileKeyPair::dueRefresh).orElse(true)
                                                                       ^
    method dueRefresh in record ProfileKeyPair cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
/home/matt/Documents/Repos/Mattcraft/net/minecraft/advancements/critereon/SlideDownBlockTrigger.java:44: error: incompatible types: DataResult<Object> cannot be converted to DataResult<TriggerInstance>
                                .orElseGet(() -> DataResult.success(triggerInstance));
                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/advancements/critereon/EnchantmentPredicate.java:33: error: incompatible types: Object cannot be converted to Holder<Enchantment>
                        for (Holder<Enchantment> holder : (HolderSet)this.enchantments.get()) {
                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/dedicated/Settings.java:127: error: incompatible types: bad return type in lambda expression
                                return (Number)function.apply(string);
                                       ^
    Number cannot be converted to V
  where V is a type-variable:
    V extends Number declared in method <V>wrapNumberDeserializer(Function<String,V>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/dedicated/Settings.java:171: error: improperly formed type, type arguments given on a raw type
                return new Settings.MutableValue<>(string, object2, function2);
                                                ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/dedicated/DedicatedServerProperties.java:236: error: incompatible types: bad return type in lambda expression
                                .or(() -> Optional.ofNullable((ResourceKey)LEGACY_PRESET_NAMES.get(this.levelType)))
                                                             ^
    Optional<ResourceKey> cannot be converted to Optional<? extends ResourceKey<WorldPreset>>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/GameRulesService.java:19: error: type argument Value<?> is not within bounds of type-variable T
                        GameRules.Value<?> value = minecraftApi.gameRuleService().getRule((GameRules.Key<GameRules.Value<?>>)key);
                                                                                                                        ^
  where T is a type-variable:
    T extends Value<T> declared in class Key
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/GameRulesService.java:19: error: method getRule in interface MinecraftGameRuleService cannot be applied to given types;
                        GameRules.Value<?> value = minecraftApi.gameRuleService().getRule((GameRules.Key<GameRules.Value<?>>)key);
                                                                                 ^
  required: Key<T>
  found:    Key<Value<?>>
  reason: inference variable T has incompatible equality constraints CAP#1,Value<?>
  where T is a type-variable:
    T extends Value<T> declared in method <T>getRule(Key<T>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Value<CAP#1> from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/dialog/action/StaticAction.java:17: error: incompatible types: MapCodec<CAP#1> cannot be converted to MapCodec<ClickEvent>
                                MapCodec<ClickEvent> mapCodec = action.valueCodec();
                                                                                 ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends ClickEvent from capture of ? extends ClickEvent
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/internalapi/MinecraftGameRuleServiceImpl.java:74: error: type argument Value<?> is not within bounds of type-variable T
                return this.server.getGameRules().getRule((net.minecraft.world.level.GameRules.Key<net.minecraft.world.level.GameRules.Value<?>>)key);
                                                                                                                                            ^
  where T is a type-variable:
    T extends Value<T> declared in class Key
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/internalapi/MinecraftGameRuleServiceImpl.java:74: error: method getRule in class GameRules cannot be applied to given types;
                return this.server.getGameRules().getRule((net.minecraft.world.level.GameRules.Key<net.minecraft.world.level.GameRules.Value<?>>)key);
                                                 ^
  required: Key<T>
  found:    Key<Value<?>>
  reason: inference variable T has incompatible equality constraints CAP#1,Value<?>
  where T is a type-variable:
    T extends Value<T> declared in method <T>getRule(Key<T>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Value<CAP#1> from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/OperatorService.java:38: error: incompatible types: Object cannot be converted to Optional<NameAndId>
                for (Optional<NameAndId> optional : (List)Util.sequence(list2).join()) {
                                                    ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/OperatorService.java:54: error: incompatible types: Object cannot be converted to Optional<Op>
                for (Optional<OperatorService.Op> optional : (List)Util.sequence(list2).join()) {
                                                             ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/OperatorService.java:71: error: incompatible types: invalid method reference
                        .filter(Optional::isPresent)
                                ^
    method isPresent in class Optional<T> cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
  where T is a type-variable:
    T extends Object declared in class Optional
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/BanlistService.java:46: error: incompatible types: Object cannot be converted to Optional<UserBan>
                for (Optional<BanlistService.UserBan> optional : (List)Util.sequence(list2).join()) {
                                                                 ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/BanlistService.java:70: error: incompatible types: Object cannot be converted to Optional<NameAndId>
                for (Optional<NameAndId> optional : (List)Util.sequence(list2).join()) {
                                                    ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/BanlistService.java:89: error: incompatible types: invalid method reference
                        .filter(Optional::isPresent)
                                ^
    method isPresent in class Optional<T> cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
  where T is a type-variable:
    T extends Object declared in class Optional
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/ServerStateService.java:40: error: incompatible types: Object cannot be converted to PlayerDto
                                for (PlayerDto playerDto : (List)systemMessage.receivingPlayers().get()) {
                                                           ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/AllowlistService.java:30: error: incompatible types: Object cannot be converted to Optional<NameAndId>
                for (Optional<NameAndId> optional : (List)Util.sequence(list2).join()) {
                                                    ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/AllowlistService.java:47: error: incompatible types: Object cannot be converted to Optional<NameAndId>
                for (Optional<NameAndId> optional : (List)Util.sequence(list2).join()) {
                                                    ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/jsonrpc/methods/AllowlistService.java:59: error: incompatible types: invalid method reference
                Set<NameAndId> set = (Set<NameAndId>)((List)Util.sequence(list2).join()).stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toSet());
                                                                                                         ^
    method isPresent in class Optional<T> cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
  where T is a type-variable:
    T extends Object declared in class Optional
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/packs/linkfs/LinkFSProvider.java:81: error: incompatible types: Iterator<LinkFSPath> cannot be converted to Iterator<Path>
                                        }).map(linkFSPath -> linkFSPath).iterator();
                                                                                 ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/ResourceOrTagArgument.java:145: error: incompatible types: bad type in conditional expression
                        return this.value.key().isFor(resourceKey) ? Optional.of(this) : Optional.empty();
                                                                                ^
    inference variable T#1 has incompatible bounds
      equality constraints: Result<E>
      lower bounds: ResourceResult<T#2>
  where T#1,E,T#2 are type-variables:
    T#1 extends Object declared in method <T#1>of(T#1)
    E extends Object declared in method <E>cast(ResourceKey<? extends Registry<E>>)
    T#2 extends Object declared in record ResourceResult
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/ResourceOrTagArgument.java:174: error: incompatible types: bad type in conditional expression
                        return this.tag.key().isFor(resourceKey) ? Optional.of(this) : Optional.empty();
                                                                              ^
    inference variable T#1 has incompatible bounds
      equality constraints: Result<E>
      lower bounds: TagResult<T#2>
  where T#1,E,T#2 are type-variables:
    T#1 extends Object declared in method <T#1>of(T#1)
    E extends Object declared in method <E>cast(ResourceKey<? extends Registry<E>>)
    T#2 extends Object declared in record TagResult
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/DebugConfigCommand.java:74: error: cannot find symbol
                                set.add(serverConfigurationPacketListenerImpl.getOwner().id().toString());
                                                                                        ^
  symbol:   method id()
  location: class GameProfile
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/OperationArgument.java:57: error: lambda expression not expected here
                return (OperationArgument.Operation)(string.equals("><") ? (scoreAccess, scoreAccess2) -> {
                                                                           ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ReturnCommand.java:25: error: incompatible types: ArgumentBuilder cannot be converted to LiteralArgumentBuilder<T>
                                .then(LiteralArgumentBuilder.<T>literal("run").forward(commandDispatcher.getRoot(), new ReturnCommand.ReturnFromCommandCustomModifier<>(), false))
                                     ^
  where T is a type-variable:
    T extends ExecutionCommandSource<T> declared in method <T>register(CommandDispatcher<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ReturnCommand.java:22: error: incompatible types: inference variable T has incompatible bounds
                        ((LiteralArgumentBuilder)LiteralArgumentBuilder.literal("return").requires(Commands.hasPermission(2)))
                                                                                         ^
    equality constraints: Object
    upper bounds: PermissionSource
  where T is a type-variable:
    T extends PermissionSource declared in method <T>hasPermission(int)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ExecuteCommand.java:986: error: cannot find symbol
                                        .filter(entityx -> !entityx.isRemoved())
                                                                   ^
  symbol:   method isRemoved()
  location: variable entityx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ExecuteCommand.java:987: error: incompatible types: Object cannot be converted to Entity
                                        .map(entityx -> List.of(commandSourceStack.withEntity(entityx)))
                                                                                              ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ForceLoadCommand.java:185: error: cannot find symbol
                                                                t,
                                                                ^
  symbol:   variable t
  location: class ForceLoadCommand
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/commands/ListPlayersCommand.java:30: error: cannot find symbol
                        serverPlayer -> Component.translatable("commands.list.nameAndId", serverPlayer.getName(), Component.translationArg(serverPlayer.getGameProfile().id()))
                                                                                                                                                                        ^
  symbol:   method id()
  location: class GameProfile
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/item/ItemInput.java:81: error: incompatible types: bad return type in lambda expression
                return this.item.unwrapKey().map(ResourceKey::location).orElseGet(() -> "unknown[" + this.item + "]").toString();
                                                                                                               ^
    String cannot be converted to ResourceLocation
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:57: error: method onProfileLookupSucceeded in interface ProfileLookupCallback cannot be applied to given types;
                                profileLookupCallback.onProfileLookupSucceeded(string, UUIDUtil.createOfflinePlayerUUID(string));
                                                     ^
  required: GameProfile
  found:    String,UUID
  reason: actual and formal argument lists differ in length
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:76: error: <anonymous net.minecraft.server.players.OldUsersConverter$1> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:77: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:167: error: <anonymous net.minecraft.server.players.OldUsersConverter$2> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:168: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:212: error: <anonymous net.minecraft.server.players.OldUsersConverter$3> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:213: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:252: error: <anonymous net.minecraft.server.players.OldUsersConverter$4> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:253: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:299: error: <anonymous net.minecraft.server.players.OldUsersConverter$5> is not abstract and does not override abstract method onProfileLookupSucceeded(GameProfile) in ProfileLookupCallback
                                ProfileLookupCallback profileLookupCallback = new ProfileLookupCallback() {
                                                                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/OldUsersConverter.java:300: error: method does not override or implement a method from a supertype
                                        @Override
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/server/players/CachedUserNameToIdResolver.java:66: error: cannot find symbol
                        Optional<NameAndId> optional = gameProfileRepository.findProfileByName(string).map(NameAndId::new);
                                                                            ^
  symbol:   method findProfileByName(String)
  location: variable gameProfileRepository of type GameProfileRepository
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/SingletonArgumentInfo.java:18: error: incompatible types: cannot infer type arguments for SingletonArgumentInfo<>
                return new SingletonArgumentInfo<>(commandBuildContext -> (ArgumentType)supplier.get());
                                                ^
    reason: inference variable A has incompatible bounds
      equality constraints: T
      lower bounds: ArgumentType
  where A,T are type-variables:
    A extends ArgumentType<?> declared in class SingletonArgumentInfo
    T extends ArgumentType<?> declared in method <T>contextFree(Supplier<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/SuggestionProviders.java:45: error: incompatible types: RegisteredSuggestion cannot be converted to SuggestionProvider<S>
                        return new SuggestionProviders.RegisteredSuggestion(resourceLocation, suggestionProvider);
                               ^
  where S is a type-variable:
    S extends SharedSuggestionProvider declared in method <S>register(ResourceLocation,SuggestionProvider<SharedSuggestionProvider>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:122: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_or_tag", fixClassType(ResourceOrTagArgument.class), new ResourceOrTagArgument.Info());
                        ^
    (argument mismatch; Class<ResourceOrTagArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:123: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_or_tag_key", fixClassType(ResourceOrTagKeyArgument.class), new ResourceOrTagKeyArgument.Info());
                        ^
    (argument mismatch; Class<ResourceOrTagKeyArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:124: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource", fixClassType(ResourceArgument.class), new ResourceArgument.Info());
                        ^
    (argument mismatch; Class<ResourceArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:125: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_key", fixClassType(ResourceKeyArgument.class), new ResourceKeyArgument.Info());
                        ^
    (argument mismatch; Class<ResourceKeyArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/synchronization/ArgumentTypeInfos.java:126: error: incompatible types: cannot infer type-variable(s) A,T#1,T#2
                register(registry, "resource_selector", fixClassType(ResourceSelectorArgument.class), new ResourceSelectorArgument.Info());
                        ^
    (argument mismatch; Class<ResourceSelectorArgument> cannot be converted to Class<? extends ArgumentType<?>>)
  where A,T#1,T#2 are type-variables:
    A extends ArgumentType<?> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#1 extends Template<A> declared in method <A,T#1>register(Registry<ArgumentTypeInfo<?,?>>,String,Class<? extends A>,ArgumentTypeInfo<A,T#1>)
    T#2 extends ArgumentType<?> declared in method <T#2>fixClassType(Class<? super T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/selector/options/EntitySelectorOptions.java:422: error: cannot find symbol
                                                        map2.put(string, (Predicate)criterionProgress -> criterionProgress.isDone() == bl);
                                                                                                                          ^
  symbol:   method isDone()
  location: variable criterionProgress of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/selector/options/EntitySelectorOptions.java:434: error: cannot find symbol
                                                                CriterionProgress criterionProgress = advancementProgress.getCriterion((String)entry.getKey());
                                                                                                                         ^
  symbol:   method getCriterion(String)
  location: variable advancementProgress of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/selector/options/EntitySelectorOptions.java:444: error: cannot find symbol
                                                map.put(resourceLocation, (Predicate)advancementProgress -> advancementProgress.isDone() == bl2);
                                                                                                                               ^
  symbol:   method isDone()
  location: variable advancementProgress of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/arguments/blocks/BlockStateParser.java:491: error: method setValue in class StateHolder<O,S> cannot be applied to given types;
                        this.state = this.state.setValue(property, (Comparable)optional.get());
                                               ^
  required: Property<T#1>,V
  found:    Property<T#2>,Comparable
  reason: inference variable T#1 has incompatible bounds
    equality constraints: T#2
    lower bounds: V,Comparable
  where T#1,V,S,T#2,O are type-variables:
    T#1 extends Comparable<T#1> declared in method <T#1,V>setValue(Property<T#1>,V)
    V extends T#1 declared in method <T#1,V>setValue(Property<T#1>,V)
    S extends Object declared in class StateHolder
    T#2 extends Comparable<T#2> declared in method <T#2>setValue(Property<T#2>,String,int)
    O extends Object declared in class StateHolder
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/execution/tasks/BuildContexts.java:56: error: RedirectModifier<T> cannot be safely cast to CustomModifierExecutor<T>
                                        if (redirectModifier instanceof CustomModifierExecutor<T> customModifierExecutor) {
                                            ^
  where T is a type-variable:
    T extends ExecutionCommandSource<T> declared in class BuildContexts
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/execution/tasks/BuildContexts.java:93: error: cannot infer type arguments for CommandQueueEntry<>
                                executionContext.queueNext(new CommandQueueEntry<>(frame, FallthroughTask.instance()));
                                                           ^
  reason: inferred type does not conform to equality constraint(s)
    inferred: T#1
    equality constraints(s): T#1,T#2
  where T#1,T#2 are type-variables:
    T#1 extends ExecutionCommandSource<T#1>
    T#2 extends ExecutionCommandSource<T#1>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/commands/execution/tasks/BuildContexts.java:97: error: Command<T> cannot be safely cast to CustomCommandExecutor<T>
                        if (commandContext2.getCommand() instanceof CustomCommandExecutor<T> customCommandExecutor) {
                                                      ^
  where T is a type-variable:
    T extends ExecutionCommandSource<T> declared in class BuildContexts
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/random/WeightedRandom.java:29: error: method pauseInIde in class Util cannot be applied to given types;
                        throw (IllegalArgumentException)Util.pauseInIde((T)(new IllegalArgumentException("Negative total weight in getRandomItem")));
                                                            ^
  required: T#1
  found:    T#2
  reason: inference variable T#1 has incompatible bounds
    upper bounds: Throwable
    lower bounds: T#2
  where T#1,T#2 are type-variables:
    T#1 extends Throwable declared in method <T#1>pauseInIde(T#1)
    T#2 extends Object declared in method <T#2>getRandomItem(RandomSource,List<T#2>,int,ToIntFunction<T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/Graph.java:20: error: incompatible types: Object cannot be converted to T
                        for (T object2 : (Set)map.getOrDefault(object, ImmutableSet.of())) {
                                         ^
  where T is a type-variable:
    T extends Object declared in method <T>depthFirstSearch(Map<T,Set<T>>,Set<T>,Set<T>,Consumer<T>,T)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/EncoderCache.java:34: error: incompatible types: inference variable T#1 has incompatible bounds
                                        .map(objectx -> objectx instanceof Tag tag ? tag.copy() : objectx);
                                            ^
    equality constraints: T#2
    lower bounds: CAP#1,Tag
  where T#1,R,T#2,A are type-variables:
    T#1 extends Object declared in method <T#1>map(Function<? super R,? extends T#1>)
    R extends Object declared in interface DataResult
    T#2 extends Object declared in method <T#2>encode(A,DynamicOps<T#2>,T#2)
    A extends Object declared in method <A>wrap(Codec<A>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/PlaceholderLookupProvider.java:46: error: incompatible types: bad return type in lambda expression
                                                        () -> Optional.of(
                                                                         ^
    Optional<RegistryInfo> cannot be converted to Optional<? extends RegistryInfo<T>>
  where T is a type-variable:
    T extends Object declared in method <T>lookup(ResourceKey<? extends Registry<? extends T>>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/PlaceholderLookupProvider.java:102: error: incompatible types: PlaceholderLookupProvider.UniversalLookup cannot be converted to HolderGetter<T>
                        return this;
                               ^
  where T is a type-variable:
    T extends Object declared in method <T>castAsLookup()
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/PlaceholderLookupProvider.java:106: error: incompatible types: PlaceholderLookupProvider.UniversalLookup cannot be converted to HolderOwner<T>
                        return this;
                               ^
  where T is a type-variable:
    T extends Object declared in method <T>castAsOwner()
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/SortedArraySet.java:32: error: cannot infer type arguments for SortedArraySet<>
                return new SortedArraySet<>(i, Comparator.naturalOrder());
                       ^
  reason: inferred type does not conform to equality constraint(s)
    inferred: T#1
    equality constraints(s): T#2
  where T#1,T#2 are type-variables:
    T#1 extends Comparable<? super T#1>
    T#2 extends Comparable<? super T#1>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/LegacyHoverEventFix.java:63: error: incompatible types: invalid method reference
                                                        String string = (String)((Either)pairxxx.getFirst()).left().map(Pair::getFirst).orElse("");
                                                                                                                        ^
    method getFirst in class Pair<F,S> cannot be applied to given types
      required: no arguments
      found:    Object
      reason: actual and formal argument lists differ in length
  where F,S are type-variables:
    F extends Object declared in class Pair
    S extends Object declared in class Pair
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityUUIDFix.java:105: error: incompatible types: Stream<Dynamic> cannot be converted to Stream<? extends Dynamic<?>>
                        .map(dynamic2 -> dynamic.createList(dynamic2.asStream().map(dynamicxx -> (Dynamic)createUUIDFromML(dynamicxx).orElseGet(() -> {
                                                                                   ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityUUIDFix.java:139: error: incompatible types: cannot infer type-variable(s) R
                                                                dynamic2x.asStream().map(dynamicxxxx -> (Dynamic)replaceUUIDLeastMost(dynamicxxxx, "UUID", "UUID").orElse(dynamicxxxx))
                                                                                        ^
    (argument mismatch; incompatible parameter types in lambda expression)
  where R,T are type-variables:
    R extends Object declared in method <R>map(Function<? super T,? extends R>)
    T extends Object declared in interface Stream
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java:132: error: cannot find symbol
                                .mapToInt(dynamicx -> dynamicx.asShort((short)-1))
                                                              ^
  symbol:   method asShort(short)
  location: variable dynamicx of type Object
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkProtoTickListFix.java:181: error: incompatible types: ImmutableMap<Object,Object> cannot be converted to Map<? extends Dynamic<?>,? extends Dynamic<?>>
                                .build()
                                      ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityBlockStateFix.java:328: error: incompatible types: invalid method reference
                        int i = either.<Integer>map(pair -> ((Either)pair.getSecond()).map(integer -> integer, EntityBlockStateFix::getBlockId), unit -> {
                                                                                                               ^
    incompatible types: Object cannot be converted to String
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityBlockStateFix.java:344: error: incompatible types: invalid method reference
                        int i = ((Either)pair.getSecond()).<Integer>map(integer -> integer, EntityBlockStateFix::getBlockId);
                                                                                            ^
    incompatible types: Object cannot be converted to String
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntityVariantFix.java:26: error: incompatible types: bad return type in lambda expression
                        Function<T, T> function2 = objectx -> ((Dynamic)function.apply(new Dynamic<>(dynamicOps, (T)objectx))).getValue();
                                                                                                                                       ^
    Object cannot be converted to T
  where T is a type-variable:
    T extends Object declared in method <T>updateAndRename(Dynamic<T>,String,String,Function<Dynamic<T>,Dynamic<T>>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/StatsCounterFix.java:244: error: incompatible types: Object cannot be converted to Entry<? extends Dynamic<?>,? extends Dynamic<?>>
                                for (Entry<? extends Dynamic<?>, ? extends Dynamic<?>> entry : ((Map)optional.get()).entrySet()) {
                                                                                                                             ^
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
Note: Some messages have been simplified; recompile with -Xdiags:verbose to get full output
100 errors
4 warnings
only showing the first 100 errors, of 229 total; use -Xmaxerrs if you would like to see more

> Task :compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileJava'.
> Compilation failed; see the compiler error output for details.

* Try:
> Run with --info option to get more log output.
> Run with --scan to get full insights.

BUILD FAILED in 26s
1 actionable task: 1 executed
matt@HungLoDE:~/Documents/Repos/Mattcraft$



