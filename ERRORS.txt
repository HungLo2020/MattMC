matt@HungLoDE:~/Documents/Repos/Mattcraft$ ./gradlew build
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/ChunkBedBlockEntityInjecterFix.java:82: error: incompatible types: Object cannot be converted to TE
                                                                                                .getFirst()
                                                                                                         ^
  where TE is a type-variable:
    TE extends Object declared in method <TE>cap(Type<?>,ListType<TE>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntitySpawnerItemVariantComponentFix.java:35: error: no suitable method found for updateTyped(OpticFinder<CAP#1>,EntitySpaw[...]ucket)
                                        case "minecraft:salmon_bucket" -> typed.updateTyped(opticFinder2, EntitySpawnerItemVariantComponentFix::fixSalmonBucket);
                                                                               ^
    method Typed.<FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#1
        (argument mismatch; incompatible parameter types in method reference))
    method Typed.<FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#2,FR
        (actual and formal argument lists differ in length))
  where FT#1,FT#2,FR are type-variables:
    FT#1 extends Object declared in method <FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>)
    FT#2 extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
    FR extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntitySpawnerItemVariantComponentFix.java:36: error: no suitable method found for updateTyped(OpticFinder<CAP#1>,EntitySpaw[...]ucket)
                                        case "minecraft:axolotl_bucket" -> typed.updateTyped(opticFinder2, EntitySpawnerItemVariantComponentFix::fixAxolotlBucket);
                                                                                ^
    method Typed.<FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#1
        (argument mismatch; incompatible parameter types in method reference))
    method Typed.<FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#2,FR
        (actual and formal argument lists differ in length))
  where FT#1,FT#2,FR are type-variables:
    FT#1 extends Object declared in method <FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>)
    FT#2 extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
    FR extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EntitySpawnerItemVariantComponentFix.java:37: error: no suitable method found for updateTyped(OpticFinder<CAP#1>,EntitySpaw[...]ucket)
                                        case "minecraft:tropical_fish_bucket" -> typed.updateTyped(opticFinder2, EntitySpawnerItemVariantComponentFix::fixTropicalFishBucket);
                                                                                      ^
    method Typed.<FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#1
        (argument mismatch; incompatible parameter types in method reference))
    method Typed.<FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>) is not applicable
      (cannot infer type-variable(s) FT#2,FR
        (actual and formal argument lists differ in length))
  where FT#1,FT#2,FR are type-variables:
    FT#1 extends Object declared in method <FT#1>updateTyped(OpticFinder<FT#1>,Function<Typed<?>,Typed<?>>)
    FT#2 extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
    FR extends Object declared in method <FT#2,FR>updateTyped(OpticFinder<FT#2>,Type<FR>,Function<Typed<?>,Typed<?>>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
Path for java installation '/usr/lib/jvm/openjdk-21' (Common Linux Locations) does not contain a java executable
Path for java installation '/usr/lib/jvm/openjdk-17' (Common Linux Locations) does not contain a java executable
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/OptionsKeyLwjgl3Fix.java:171: error: incompatible types: Dynamic<CAP#1> cannot be converted to Dynamic<CAP#2>
                                        .orElse(dynamic)
                                                ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
error: incompatible types: incompatible parameter types in lambda expression
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/EquipmentFormatFix.java:66: error: incompatible types: inference variable F has incompatible bounds
                        return this.fixTypeEverywhere(
                                                     ^
    equality constraints: Either<ItemStackNew,Unit>
    lower bounds: Either<ItemStackOld,Unit>
  where F,S,ItemStackNew,ItemStackOld are type-variables:
    F extends Object declared in method <F,S>of(F,S)
    S extends Object declared in method <F,S>of(F,S)
    ItemStackNew extends Object declared in method <ItemStackOld,ItemStackNew>fix(Type<ItemStackOld>,Type<ItemStackNew>,OpticFinder<?>)
    ItemStackOld extends Object declared in method <ItemStackOld,ItemStackNew>fix(Type<ItemStackOld>,Type<ItemStackNew>,OpticFinder<?>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/OptionsKeyTranslationFix.java:37: error: incompatible types: Dynamic<CAP#1> cannot be converted to Dynamic<CAP#2>
                                        .orElse(dynamic)
                                                ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/util/datafix/fixes/BlockEntityUUIDFix.java:27: error: incompatible types: Dynamic<CAP#1> cannot be converted to Dynamic<CAP#2>
                        .orElse(dynamic);
                                ^
  where CAP#1,CAP#2 are fresh type-variables:
    CAP#1 extends Object from capture of ?
    CAP#2 extends Object from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/item/AdventureModePredicate.java:121: error: incompatible types: incompatible parameter types in lambda expression
                        .map((Holder<Block> holder) -> ((Block)holder.value()).getName().withStyle(ChatFormatting.DARK_GRAY))
                                                                                                  ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/item/HoneycombItem.java:109: error: incompatible types: Pass cannot be converted to Success
                }).orElse(InteractionResult.PASS);
                                           ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/item/component/DebugStickState.java:21: error: incompatible types: bad return type in method reference
                .xmap(map -> new DebugStickState((Map<Holder<Block>, Property<?>>)(Map<?, ?>)map), DebugStickState::properties);
                                                                                                   ^
    Map<Holder<Block>,Property<?>> cannot be converted to Map<Holder<Block>,Property<CAP#1>>
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Comparable<CAP#1> from capture of ?
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/entity/monster/piglin/PiglinAi.java:173: error: incompatible types: ImmutableList<BehaviorControl> cannot be converted to ImmutableList<? extends BehaviorControl<? super Piglin>>
                        ImmutableList.of(
                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/entity/monster/piglin/PiglinAi.java:245: error: no suitable method found for add(Pair<OneShot<Piglin>,Integer>)
                                                        .add(Pair.of(BehaviorBuilder.<Piglin>triggerIf(piglin -> true), 1))
                                                        ^
    method Builder.add(Pair<? extends Trigger<? super LivingEntity>,Integer>) is not applicable
      (argument mismatch; inference variable F has incompatible bounds
          upper bounds: Trigger<? super LivingEntity>,Object
          lower bounds: OneShot<Piglin>)
    method Builder.add(Pair<? extends Trigger<? super LivingEntity>,Integer>...) is not applicable
      (varargs mismatch; inference variable F has incompatible bounds
          upper bounds: Trigger<? super LivingEntity>,Object
          lower bounds: OneShot<Piglin>)
  where F,S are type-variables:
    F extends Object declared in method <F,S>of(F,S)
    S extends Object declared in method <F,S>of(F,S)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/predicates/LootItemBlockStatePropertyCondition.java:31: error: incompatible types: DataResult<Object> cannot be converted to DataResult<LootItemBlockStatePropertyCondition>
                        .map(string -> (DataResult<LootItemBlockStatePropertyCondition>)DataResult.error(() -> "Block " + lootItemBlockStatePropertyCondition.block() + " has no property" + string))
                                                                                                        ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetNameFunction.java:60: error: incompatible types: Set<ContextKey<CAP#1>> cannot be converted to Set<ContextKey<?>>
                return (Set<ContextKey<?>>)this.resolutionContext.map(entityTarget -> Set.of(entityTarget.getParam())).orElse(Set.of());
                                                                                                                             ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Entity from capture of ? extends Entity
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetContainerLootTable.java:22: error: no suitable method found for and(P3<Mu<SetContainerLootTable>,ResourceKey<LootTable>,Long,Holder<BlockEntityType<?>>>)
                        .<ResourceKey<LootTable>, long, Holder<BlockEntityType<?>>>and(
                        ^
    method P1.<T2#1>and(App<Mu<SetContainerLootTable>,T2#1>) is not applicable
      (wrong number of type arguments; required 1)
    method P1.<T2#2,T3#1>and(P2<Mu<SetContainerLootTable>,T2#2,T3#1>) is not applicable
      (wrong number of type arguments; required 2)
    method P1.<T2#3,T3#2,T4#1>and(P3<Mu<SetContainerLootTable>,T2#3,T3#2,T4#1>) is not applicable
      (explicit type argument long does not conform to declared bound(s) Object)
    method P1.<T2#4,T3#3,T4#2,T5#1>and(P4<Mu<SetContainerLootTable>,T2#4,T3#3,T4#2,T5#1>) is not applicable
      (wrong number of type arguments; required 4)
    method P1.<T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<Mu<SetContainerLootTable>,T2#5,T3#4,T4#3,T5#2,T6#1>) is not applicable
      (wrong number of type arguments; required 5)
    method P1.<T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<Mu<SetContainerLootTable>,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>) is not applicable
      (wrong number of type arguments; required 6)
    method P1.<T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<Mu<SetContainerLootTable>,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>) is not applicable
      (wrong number of type arguments; required 7)
  where T2#1,F,T1,T2#2,T3#1,T2#3,T3#2,T4#1,T2#4,T3#3,T4#2,T5#1,T2#5,T3#4,T4#3,T5#2,T6#1,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8 are type-variables:
    T2#1 extends Object declared in method <T2#1>and(App<F,T2#1>)
    F extends K1 declared in class P1
    T1 extends Object declared in class P1
    T2#2 extends Object declared in method <T2#2,T3#1>and(P2<F,T2#2,T3#1>)
    T3#1 extends Object declared in method <T2#2,T3#1>and(P2<F,T2#2,T3#1>)
    T2#3 extends Object declared in method <T2#3,T3#2,T4#1>and(P3<F,T2#3,T3#2,T4#1>)
    T3#2 extends Object declared in method <T2#3,T3#2,T4#1>and(P3<F,T2#3,T3#2,T4#1>)
    T4#1 extends Object declared in method <T2#3,T3#2,T4#1>and(P3<F,T2#3,T3#2,T4#1>)
    T2#4 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T3#3 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T4#2 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T5#1 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T2#5 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T3#4 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T4#3 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T5#2 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T6#1 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T2#6 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T3#5 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T4#4 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T5#3 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T6#2 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T7#1 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T2#7 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T3#6 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T4#5 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T5#4 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T6#3 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T7#2 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T8 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetContainerLootTable.java:22: error: unexpected type
                        .<ResourceKey<LootTable>, long, Holder<BlockEntityType<?>>>and(
                                                  ^
  required: reference
  found:    long
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetLoreFunction.java:50: error: incompatible types: Set<ContextKey<CAP#1>> cannot be converted to Set<ContextKey<?>>
                return (Set<ContextKey<?>>)this.resolutionContext.map(entityTarget -> Set.of(entityTarget.getParam())).orElseGet(Set::of);
                                                                                                                                ^
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Entity from capture of ? extends Entity
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetBannerPatternFunction.java:19: error: no suitable method found for and(P2<Mu<SetBannerPatternFunction>,BannerPatternLayers,Boolean>)
                        .<BannerPatternLayers, boolean>and(
                        ^
    method P1.<T2#1>and(App<Mu<SetBannerPatternFunction>,T2#1>) is not applicable
      (wrong number of type arguments; required 1)
    method P1.<T2#2,T3#1>and(P2<Mu<SetBannerPatternFunction>,T2#2,T3#1>) is not applicable
      (explicit type argument boolean does not conform to declared bound(s) Object)
    method P1.<T2#3,T3#2,T4#1>and(P3<Mu<SetBannerPatternFunction>,T2#3,T3#2,T4#1>) is not applicable
      (wrong number of type arguments; required 3)
    method P1.<T2#4,T3#3,T4#2,T5#1>and(P4<Mu<SetBannerPatternFunction>,T2#4,T3#3,T4#2,T5#1>) is not applicable
      (wrong number of type arguments; required 4)
    method P1.<T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<Mu<SetBannerPatternFunction>,T2#5,T3#4,T4#3,T5#2,T6#1>) is not applicable
      (wrong number of type arguments; required 5)
    method P1.<T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<Mu<SetBannerPatternFunction>,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>) is not applicable
      (wrong number of type arguments; required 6)
    method P1.<T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<Mu<SetBannerPatternFunction>,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>) is not applicable
      (wrong number of type arguments; required 7)
  where T2#1,F,T1,T2#2,T3#1,T2#3,T3#2,T4#1,T2#4,T3#3,T4#2,T5#1,T2#5,T3#4,T4#3,T5#2,T6#1,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8 are type-variables:
    T2#1 extends Object declared in method <T2#1>and(App<F,T2#1>)
    F extends K1 declared in class P1
    T1 extends Object declared in class P1
    T2#2 extends Object declared in method <T2#2,T3#1>and(P2<F,T2#2,T3#1>)
    T3#1 extends Object declared in method <T2#2,T3#1>and(P2<F,T2#2,T3#1>)
    T2#3 extends Object declared in method <T2#3,T3#2,T4#1>and(P3<F,T2#3,T3#2,T4#1>)
    T3#2 extends Object declared in method <T2#3,T3#2,T4#1>and(P3<F,T2#3,T3#2,T4#1>)
    T4#1 extends Object declared in method <T2#3,T3#2,T4#1>and(P3<F,T2#3,T3#2,T4#1>)
    T2#4 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T3#3 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T4#2 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T5#1 extends Object declared in method <T2#4,T3#3,T4#2,T5#1>and(P4<F,T2#4,T3#3,T4#2,T5#1>)
    T2#5 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T3#4 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T4#3 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T5#2 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T6#1 extends Object declared in method <T2#5,T3#4,T4#3,T5#2,T6#1>and(P5<F,T2#5,T3#4,T4#3,T5#2,T6#1>)
    T2#6 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T3#5 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T4#4 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T5#3 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T6#2 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T7#1 extends Object declared in method <T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>and(P6<F,T2#6,T3#5,T4#4,T5#3,T6#2,T7#1>)
    T2#7 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T3#6 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T4#5 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T5#4 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T6#3 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T7#2 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
    T8 extends Object declared in method <T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>and(P7<F,T2#7,T3#6,T4#5,T5#4,T6#3,T7#2,T8>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetBannerPatternFunction.java:19: error: unexpected type
                        .<BannerPatternLayers, boolean>and(
                                               ^
  required: reference
  found:    boolean
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/CopyComponentsFunction.java:75: error: method getTyped in interface DataComponentGetter cannot be applied to given types;
                                                        TypedDataComponent<?> typedDataComponent = dataComponentGetter.getTyped(dataComponentType);
                                                                                                                      ^
  required: DataComponentType<T>
  found:    Object
  reason: cannot infer type-variable(s) T
    (argument mismatch; Object cannot be converted to DataComponentType<T>)
  where T is a type-variable:
    T extends Object declared in method <T>getTyped(DataComponentType<T>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetCustomModelDataFunction.java:24: error: no suitable method found for withAlternative(Codec<NumberProvider>,Codec<Integer>,ConstantValue::new)
        private static final Codec<NumberProvider> COLOR_PROVIDER_CODEC = Codec.withAlternative(NumberProviders.CODEC, ExtraCodecs.RGB_COLOR_CODEC, ConstantValue::new);
                                                                               ^
    method Codec.<T#1>withAlternative(Codec<T#1>,Codec<? extends T#1>) is not applicable
      (cannot infer type-variable(s) T#1
        (actual and formal argument lists differ in length))
    method Codec.<T#2,U>withAlternative(Codec<T#2>,Codec<U>,Function<U,T#2>) is not applicable
      (inference variable U has incompatible bounds
        equality constraints: Integer
        upper bounds: Float,Object)
  where T#1,T#2,U are type-variables:
    T#1 extends Object declared in method <T#1>withAlternative(Codec<T#1>,Codec<? extends T#1>)
    T#2 extends Object declared in method <T#2,U>withAlternative(Codec<T#2>,Codec<U>,Function<U,T#2>)
    U extends Object declared in method <T#2,U>withAlternative(Codec<T#2>,Codec<U>,Function<U,T#2>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/world/level/storage/loot/functions/SetCustomModelDataFunction.java:85: error: incompatible types: List<E> cannot be converted to List<T>
                }).orElse(list);
                          ^
  where E,T are type-variables:
    E extends Object declared in method <T,E>apply(Optional<StandAlone<T>>,List<E>,Function<T,E>)
    T extends Object declared in method <T,E>apply(Optional<StandAlone<T>>,List<E>,Function<T,E>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/registries/BuiltInRegistries.java:356: error: incompatible types: ResourceKey<CAP#1> cannot be converted to ResourceKey<WritableRegistry<?>>
                WRITABLE_REGISTRY.register((ResourceKey<WritableRegistry<?>>)resourceKey, writableRegistry, RegistrationInfo.BUILT_IN);
                                                                             ^
  where T,R are type-variables:
    T extends Object declared in method <T,R>internalRegister(ResourceKey<? extends Registry<T>>,R,RegistryBootstrap<T>)
    R extends WritableRegistry<T> declared in method <T,R>internalRegister(ResourceKey<? extends Registry<T>>,R,RegistryBootstrap<T>)
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Registry<T> from capture of ? extends Registry<T>
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/MappedRegistry.java:93: error: method pauseInIde in class Util cannot be applied to given types;
                        throw (IllegalStateException)Util.pauseInIde((T)(new IllegalStateException("Adding duplicate key '" + resourceKey + "' to registry")));
                                                         ^
  required: T#1
  found:    T#2
  reason: inference variable T#1 has incompatible bounds
    upper bounds: Throwable
    lower bounds: T#2
  where T#1,T#2 are type-variables:
    T#1 extends Throwable declared in method <T#1>pauseInIde(T#1)
    T#2 extends Object declared in class MappedRegistry
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/MappedRegistry.java:95: error: method pauseInIde in class Util cannot be applied to given types;
                        throw (IllegalStateException)Util.pauseInIde((T)(new IllegalStateException("Adding duplicate value '" + object + "' to registry")));
                                                         ^
  required: T#1
  found:    T#2
  reason: inference variable T#1 has incompatible bounds
    upper bounds: Throwable
    lower bounds: T#2
  where T#1,T#2 are type-variables:
    T#1 extends Throwable declared in method <T#1>pauseInIde(T#1)
    T#2 extends Object declared in class MappedRegistry
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/component/DataComponents.java:395: error: no suitable method found for register(Registry<DataComponentType<?>>,String,DataComponentType)
                return Registry.register(BuiltInRegistries.DATA_COMPONENT_TYPE, string, ((DataComponentType.Builder)unaryOperator.apply(DataComponentType.builder())).build());
                               ^
    method Registry.<T#1>register(Registry<? super T#1>,String,T#1) is not applicable
      (cannot infer type-variable(s) T#1
        (argument mismatch; Registry<DataComponentType<?>> cannot be converted to Registry<? super DataComponentType>))
    method Registry.<V#1,T#2>register(Registry<V#1>,ResourceLocation,T#2) is not applicable
      (cannot infer type-variable(s) V#1,T#2
        (argument mismatch; String cannot be converted to ResourceLocation))
    method Registry.<V#2,T#3>register(Registry<V#2>,ResourceKey<V#2>,T#3) is not applicable
      (cannot infer type-variable(s) V#2,T#3
        (argument mismatch; String cannot be converted to ResourceKey<V#2>))
  where T#1,V#1,T#2,V#2,T#3 are type-variables:
    T#1 extends Object declared in method <T#1>register(Registry<? super T#1>,String,T#1)
    V#1 extends Object declared in method <V#1,T#2>register(Registry<V#1>,ResourceLocation,T#2)
    T#2 extends V#1 declared in method <V#1,T#2>register(Registry<V#1>,ResourceLocation,T#2)
    V#2 extends Object declared in method <V#2,T#3>register(Registry<V#2>,ResourceKey<V#2>,T#3)
    T#3 extends V#2 declared in method <V#2,T#3>register(Registry<V#2>,ResourceKey<V#2>,T#3)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/core/component/predicates/JukeboxPlayablePredicate.java:34: error: incompatible types: Object cannot be converted to Holder<JukeboxSong>
                        for (Holder<JukeboxSong> holder : (HolderSet)this.song.get()) {
                                                          ^
/home/matt/Documents/Repos/Mattcraft/net/minecraft/network/chat/ComponentUtils.java:73: error: incompatible types: Comparable cannot be converted to T
                        return (Component)function.apply((Comparable)collection.iterator().next());
                                                         ^
  where T is a type-variable:
    T extends Comparable<T> declared in method <T>formatAndSortList(Collection<T>,Function<T,Component>)
/home/matt/Documents/Repos/Mattcraft/net/minecraft/network/syncher/EntityDataSerializers.java:93: error: incompatible types: inference variable V has incompatible equality constraints EntityReference<LivingEntity>,EntityReference<UniquelyIdentifyable>
        public static final EntityDataSerializer<Optional<EntityReference<LivingEntity>>> OPTIONAL_LIVING_ENTITY_REFERENCE = EntityDataSerializer.forValueType(
                                                                                                                                                              ^
  where V,B are type-variables:
    V extends Object declared in method <B,V>optional(StreamCodec<? super B,V>)
    B extends ByteBuf declared in method <B,V>optional(StreamCodec<? super B,V>)
Note: Some input files use or override a deprecated API.
Note: Recompile with -Xlint:deprecation for details.
Note: Some input files use unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
Note: Some messages have been simplified; recompile with -Xdiags:verbose to get full output
59 errors
4 warnings
> Task :compileJava FAILED

FAILURE: Build failed with an exception.

* What went wrong:
Execution failed for task ':compileJava'.
> Compilation failed; see the compiler error output for details.

* Try:
> Run with --info option to get more log output.
> Run with --scan to get full insights.

BUILD FAILED in 47s
1 actionable task: 1 executed
matt@HungLoDE:~/Documents/Repos/Mattcraft$



